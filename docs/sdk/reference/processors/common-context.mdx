---
sidebar_position: 10
title: Common batch context
description: The argument of the batch handler
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Batch handler takes a single argument of `DataHandlerContext` type:
```ts
export interface DataHandlerContext<Store, F extends FieldSelection> {
    _chain: Chain
    log: Logger
    store: Store
    blocks: BlockData<F>[]
    isHead: boolean
}
```

Here, `F` is the type of the argument of the `setFields()` ([EVM](/sdk/reference/processors/evm-batch/field-selection), [Substrate](/sdk/reference/processors/substrate-batch/field-selection)) processor configuration method. `Store` type is inferred from the `Database` instance passed into the `run()` method.

#### `ctx._chain`

Internal handle for direct access to the underlying chain state via RPC calls. Rarely used directly, but rather by the facade access classes generated by the [typegen tools](/glossary/#typegen).

#### `ctx.log`

The native logger handle. See [Logging](/sdk/reference/logger).

#### `ctx.store`

Interface for the target data sink. See [Persisting data](/sdk/resources/store).

#### `ctx.blocks`

On-chain data items are grouped into blocks, with each block containing a header and iterables for all supported data item types. Boundary blocks are always included into the `ctx.blocks` iterable with valid headers, even when they do not contain any requested data. It follows that batch context _always_ contains at least one block.

The set of iterables depends on the processor type (docs for [EVM](/sdk/reference/processors/evm-batch/context-interfaces)/[Substrate](/sdk/reference/processors/substrate-batch/context-interfaces)). Depending on the data item type, items within the iterables can be canonically ordered by how the data is recorded on-chain (e.g. transactions are ordered but traces are not). The shape of item objects is determined by the processor configuration done via the `.setFields()` method.

An idiomatic use of the context API is to iterate first over blocks and then over each iterable of each block:

```mdx-code-block
<Tabs>
<TabItem value="evm" label="EVM">
```

```ts
processor.run(new TypeormDatabase(), async (ctx) => {
  for (let block of ctx.blocks) {
    for (let log of block.logs) {
      // filter and process logs
    }
    for (let txn of block.transactions) {
      // filter and process transactions
    }
    for (let stDiff of block.stateDiffs) {
      // filter and process state diffs
    }
    for (let traces of block.traces) {
      // filter and process execution traces
    }
  }
})
```

```mdx-code-block
</TabItem>
<TabItem value="substrate" label="Substrate">
```

```ts
processor.run(new TypeormDatabase(), async (ctx) => {
  for (let block of ctx.blocks) {
    for (let event of block.events) {
      // filter and process events
    }
    for (let call of block.calls) {
      // filter and process calls
    }
    for (let extrinsic of block.extrinsics) {
      // filter and process extrinsics
    }
  }
})
```

```mdx-code-block
</TabItem>
</Tabs>
```

The canonical ordering of `ctx.blocks` enables efficient in-memory data processing. For example, multiple updates of the same entity can be compressed into a single database transaction.

Please be aware that the processor cannot ensure that data not meeting its filters will be excluded from iterables. It only guarantees the inclusion of data that matches the filters. Therefore, it is necessary to filter the data in the batch handler prior to processing.

#### `ctx.isHead`

Is `true` if the processor has reached the chain head. The last block `ctx.blocks` is then the current chain tip.
