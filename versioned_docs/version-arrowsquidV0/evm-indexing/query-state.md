---
sidebar_position: 40
description: >-
  Query the historical state
---

# Query the contract state

In order to make on-chain calls, one must set up a Websocket JSON-RPC endpoint using [setDataSource()](/arrowsquid-docs-v0/evm-indexing/configuration/initialization). We recommend using a private endpoint from e.g. [BlastAPI](https://blastapi.io/) or the Subsquid Cloud's [RPC proxy](/arrowsquid-docs-v0/deploy-squid/rpc-proxy) service, and set it via an environment variable:

```ts
//... 
  .setDataSource({
    chain: process.env.RPC_ETH_HTTP,
    archive: lookupArchive('eth-mainnet'),
  })
//...
```
You can define the `RPC_ETH_HTTP` in three ways:
 - for local runs, simply update the local `.env` file;
 - for squids deployed to Cloud define it as a [secret](/arrowsquid-docs-v0/deploy-squid/env-variables) on your Cloud account;
 - if you are using the [RPC proxy service](/arrowsquid-docs-v0/deploy-squid/rpc-proxy), leave it to the Cloud to define it for you.

## `Contract` class

The EVM contract state is accessed using the `Contract` class generated by [`squid-evm-typegen(1)`](/arrowsquid-docs-v0/evm-indexing/squid-evm-typegen). It takes a handler context and a contract address as constructor arguments. The state is always accessed at the context block height unless explicitly defined in the constructor.

For example, assume that we index an ERC721 contract. Typescript ABI module generated with `squid-evm-typegen` will contain the following class:

```typescript
export class Contract extends ContractBase {
  //...
  balanceOf(owner: string): Promise<ethers.BigNumber> {
    return this.call('balanceOf', [owner])
  }
  //...
}
```
Now suppose we want to query our contract from the batch handler. To create a `Contract` pass the context object and the current `Block` to its constructor, then query the contract state at that block:
```ts
// ...
const CONTRACT_ADDRESS = '0xb654611f84a8dc429ba3cb4fda9fad236c505a1a'

processor.run(new TypeormDatabase(), async ctx => {
  for (const block of ctx.blocks) { 
    const contract = new abi.Contract(ctx, block.header, CONTRACT_ADDRESS)
    // query the contract state at the current block
    const uri = await contract.balanceOf('0xd8da6bf26964af9d7eed9e03e53415d37aa96045')
    // ...
  }
})
```
For more information on EVM Typegen, see this [dedicated page](/arrowsquid-docs-v0/evm-indexing/squid-evm-typegen/#contract-state-calls).

## Batch state queries

The [MakerDAO Multicall contract](https://github.com/makerdao/multicall) was designed to batch multiple state queries into a single contract call. In the context of indexing, it normally significantly improves the indexing speed since JSON RPC calls are typically the bottleneck.

Multicall contracts are deployed in many EVM chains, see the [contract repo](https://github.com/makerdao/multicall) for addresses. You can use any of them with a `multicall` Typescript module that is generated when running [`squid-evm-typegen`](/arrowsquid-docs-v0/evm-indexing/squid-evm-typegen) with `--multicall` option. The module exports a `Multicall` class with this method:
```ts
tryAggregate<Args extends any[], R>(
  func: Func<Args, {}, R>,
  calls: [address: string, args: Args][],
  paging?: number
): Promise<MulticallResult<R>[]>
```
The arguments are as follows:
- `func`: the contract function to be called
- `calls`: an array of tuples `[contractAddress: string, args]`. Each specified contract will be called with the specified arguments.
- `paging` an (optional) argument for the maximal number of calls to be batched into a single JSON PRC request. Note that large page sizes may cause timeouts.

A typical usage is as follows:
```ts title=src/main.ts
// generated by evm-typegen
import { functions } from './abi/mycontract'
import { Multicall } from './abi/multicall'

const MY_CONTRACT = '0xac5c7493036de60e63eb81c5e9a440b42f47ebf5'
const MULTICALL_CONTRACT = '0x5ba1e12693dc8f9c48aad8770482f4739beed696'

processor.run(new TypeormDatabase(), async (ctx) => {
  for (let c of ctx.blocks) {
    // some logic
  }
  const lastBlock = ctx.blocks[ctx.blocks.length - 1]
  const multicall = new Multicall(
    ctx,
    lastBlock,
    MULTICALL_CONTRACT
  )
  // call MY_CONTRACT.myContractMethod('foo') and MY_CONTRACT.myContractMethod('bar')
  const args = ['foo', 'bar']
  const results = await multicall.tryAggregate(
    functions.myContractMethod,
    args.map(a => [MY_CONTRACT, a]) as [string, any[]],
    100
  )

  results.forEach((res, i) => {
    if (res.success) {
      ctx.log.info(`Result for argument ${args[i]} is ${res.value}`)
    }
  }) 
})
```
